ci_theta1 <- quantile(theta1_2_trunc[,1], c(0.025,0.5,0.975))
ci_theta2 <- quantile(theta1_2_trunc[,2], c(0.025,0.5,0.975))
ci_theta1
ci_theta2
library(tibble)
library(ggplot2)
library(tidyverse)
set.seed(1001)  # Ensures reproducibility
x <- 3
x_bar <- mean(x)
n <- length(x)
N <- 10000 #number of samples
theta1_2=matrix(0,nrow=N,ncol=2) #Initialize matrix to save output
theta1_2[1,] = c(10,18)
head(theta1_2)
#parameters for theta1
theta1_a <- 12
theta1_b <- 3 + 1/x
#parameters for theta2
theta2_a <- x + 1/2 #not mu-dependent
theta2_b <- 1
for(i in 2:N){
theta1_2[i,1]=rgamma(1, shape=theta1_a, rate=theta1_b )
theta1_2[i,2]=rgamma(1, shape=theta2_a, rate=theta2_b )
}
gibbed <- tibble(theta1=theta1_2[,1], theta2=theta1_2[,2])
gibbed %>%
ggplot( aes(x=theta1, y=theta2) ) +
geom_hex(bins = 70) + #or try geom_bin2d
scale_fill_continuous(type = "viridis") +
theme_bw()
theta1_2_trunc <- theta1_2[-1:-10,] #remove first three rows
gibbed_trunc <- tibble(theta1=theta1_2_trunc[,1], theta2=theta1_2_trunc
[,2])
gibbed_trunc %>%
ggplot( aes(x=theta1, y=theta2) ) +
geom_hex(bins = 70) + #or try geom_bin2d
scale_fill_continuous(type = "viridis") +
theme_bw()
pacman::p_load(bayesforecast) #contains a ggplot style acf
ggacf(theta1_2)
ci_theta1 <- quantile(theta1_2_trunc[,1], c(0.025,0.5,0.975))
ci_theta2 <- quantile(theta1_2_trunc[,2], c(0.025,0.5,0.975))
ci_theta1
ci_theta2
library(MASS)
set.seed(1001)
x <- 3
iterations <- 10000
theta1_samples <- numeric(iterations)
theta2_samples <- numeric(iterations)
theta1 <- 1
theta2 <- 1
for (i in 1:iterations) {
theta1 <- rgamma(1, shape = x + 2, rate = 4 + 1/theta2)
theta2 <- rgamma(1, shape = x + 0.5, rate = 1)
theta1_samples[i] <- theta1
theta2_samples[i] <- theta2
}
# Calculate mean estimates and 95% credible intervals
mean_theta1 <- mean(theta1_samples)
ci_theta1 <- quantile(theta1_samples, c(0.025, 0.975))
mean_theta2 <- mean(theta2_samples)
ci_theta2 <- quantile(theta2_samples, c(0.025, 0.975))
# Print results
cat("Mean estimate of theta1:", mean_theta1, "\n")
cat("95% CI for theta1:", ci_theta1, "\n")
cat("Mean estimate of theta2:", mean_theta2, "\n")
cat("95% CI for theta2:", ci_theta2, "\n")
theta2_samples <- theta2_samples[-1:-10]
mean_theta2 <- mean(theta2_samples)
ci_theta2 <- quantile(theta2_samples, c(0.025, 0.975))
# Print results
cat("Mean estimate of theta1:", mean_theta1, "\n")
cat("95% CI for theta1:", ci_theta1, "\n")
cat("Mean estimate of theta2:", mean_theta2, "\n")
cat("95% CI for theta2:", ci_theta2, "\n")
# 设置随机数种子
set.seed(1001)
# 生成数据
data = 3
# Gibbs 抽样参数设置
N <- 10000
thetas = matrix(1, nrow = N, ncol = 2)
for(i in 2:N){
thetas[i, 1] = rgamma(1, 12, 3 + 1/data)
thetas[i, 2] = rgamma(1, data + 0.5, 1)
}
# 去除 burn - in 样本
thetas_trunc <- thetas[-1:-10, ]
gibbed <- data.frame(theta1 = thetas_trunc[, 1], theta2 = thetas_trunc[, 2])
# 绘制二维直方图
p <- gibbed %>%
ggplot(aes(x = theta1, y = theta2)) +
geom_bin2d(bins = 50) +
scale_fill_continuous(type = "viridis") +
theme_bw()
print(p)
# 计算均值估计
print(gibbed %>% summarise(mean(theta1), mean(theta2)))
# 计算置信区间
print(thetas_trunc[, 1] %>% quantile(c(0.025, 0.975)))
print(thetas_trunc[, 2] %>% quantile(c(0.025, 0.975)))
#  Initial Setup
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
set.seed(1001)  #  Set random seed for reproducibility
# 1. Initialization
x <- 3          #  Observed data
n_iter <- 10000 #  Total iterations
burn_in <- 1000 #  Burn-in period
# 2. Initialize storage matrix
samples <- matrix(NA, nrow = n_iter, ncol = 2,
dimnames = list(NULL, c("theta1", "theta2")))
current <- c(theta1 = 1, theta2 = 1)  # Initial values
# 3.nGibbs Sampling Main Loop
for (i in 1:n_iter) {
# (1)  Update theta1:Gamma(12, 3 + 1/x)
current["theta1"] <- rgamma(1, shape = 12, rate = 3 + 1/x)
# (2) Update theta2: Gamma(x + 0.5, 1)
current["theta2"] <- rgamma(1, shape = x + 0.5, rate = 1)
# Store current sample
samples[i, ] <- current
# Show progress every 2000 iterations
if (i %% 2000 == 0) {
cat(sprintf("Completed %d iterations\n", i, i))
}
}
# 4. Post-processing: Remove burn-in
post_samples <- samples[(burn_in + 1):n_iter, ]
# 5. Compute Statistics
#  Posterior means
post_means <- colMeans(post_samples)
#  95% Credible Intervals
post_ci <- apply(post_samples, 2, quantile, probs = c(0.025, 0.975))
# 6.  Display Results
results <- data.frame(
Parameter = c("θ₁", "θ₂"),
Mean = post_means,
Lower_CI = post_ci[1, ],
Upper_CI = post_ci[2, ],
row.names = NULL
)
knitr::kable(results,
caption = " Posterior Estimation Results",
digits = 3)
#  Initial Setup
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
set.seed(1001)  #  Set random seed for reproducibility
# 1. Initialization
x <- 3          #  Observed data
n_iter <- 10000 #  Total iterations
burn_in <- 1000 #  Burn-in period
# 2. Initialize storage matrix
samples <- matrix(NA, nrow = n_iter, ncol = 2,
dimnames = list(NULL, c("theta1", "theta2")))
current <- c(theta1 = 1, theta2 = 1)  # Initial values
# 3.nGibbs Sampling Main Loop
for (i in 1:n_iter) {
# (1)  Update theta1:Gamma(12, 3 + 1/x)
current["theta1"] <- rgamma(1, shape = 12, rate = 3 + 1/x)
# (2) Update theta2: Gamma(x + 0.5, 1)
current["theta2"] <- rgamma(1, shape = x + 0.5, rate = 1)
# Store current sample
samples[i, ] <- current
# Show progress every 2000 iterations
if (i %% 2000 == 0) {
cat(sprintf("Completed %d iterations\n", i, i))
}
}
# 4. Post-processing: Remove burn-in
post_samples <- samples[(burn_in + 1):n_iter, ]
# 5. Compute Statistics
#  Posterior means
post_means <- colMeans(post_samples)
#  95% Credible Intervals
post_ci <- apply(post_samples, 2, quantile, probs = c(0.025, 0.975))
# 6.  Display Results
results <- data.frame(
Parameter = c("θ₁", "θ₂"),
Mean = post_means,
Lower_CI = post_ci[1, ],
Upper_CI = post_ci[2, ],
row.names = NULL
)
#  Initial Setup
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
set.seed(1001)  #  Set random seed for reproducibility
# 1. Initialization
x <- 3          #  Observed data
n_iter <- 10000 #  Total iterations
burn_in <- 1000 #  Burn-in period
# 2. Initialize storage matrix
samples <- matrix(NA, nrow = n_iter, ncol = 2,
dimnames = list(NULL, c("theta1", "theta2")))
current <- c(theta1 = 1, theta2 = 1)  # Initial values
# 3.nGibbs Sampling Main Loop
for (i in 1:n_iter) {
# (1)  Update theta1:Gamma(12, 3 + 1/x)
current["theta1"] <- rgamma(1, shape = 12, rate = 3 + 1/x)
# (2) Update theta2: Gamma(x + 0.5, 1)
current["theta2"] <- rgamma(1, shape = x + 0.5, rate = 1)
# Store current sample
samples[i, ] <- current
# Show progress every 2000 iterations
if (i %% 2000 == 0) {
cat(sprintf("Completed %d iterations\n", i, i))
}
}
# 4. Post-processing: Remove burn-in
post_samples <- samples[(burn_in + 1):n_iter, ]
# 5. Compute Statistics
#  Posterior means
post_means <- colMeans(post_samples)
#  95% Credible Intervals
post_ci <- apply(post_samples, 2, quantile, probs = c(0.025, 0.975))
# 6.  Display Results
results <- data.frame(
Parameter = c("θ₁", "θ₂"),
Mean = post_means,
Lower_CI = post_ci[1, ],
Upper_CI = post_ci[2, ],
row.names = NULL
)
knitr::kable(results,
caption = " Posterior Estimation Results",
digits = 3)
# 7.  Diagnostic Visualization
par(mfrow = c(2, 2))
#  Trace plots
plot(post_samples[, "theta1"], type = "l",
main = expression(paste(theta[1], "Trace Plot")),
ylab = expression(theta[1]))
plot(post_samples[, "theta2"], type = "l",
main = expression(paste(theta[2], "Trace Plot")),
ylab = expression(theta[2]))
#  Posterior density plots
hist(post_samples[, "theta1"],
main = expression(paste(theta[1], "Posterior Distribution")),
xlab = expression(theta[1]), freq = FALSE)
hist(post_samples[, "theta2"],
main = expression(paste(theta[2], "Posterior Distribution")),
xlab = expression(theta[2]), freq = FALSE)
#  Initial Setup
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
set.seed(1001)  #  Set random seed for reproducibility
# 1. Initialization
x <- 3          #  Observed data
n_iter <- 10000 #  Total iterations
burn_in <- 1000 #  Burn-in period
# 2. Initialize storage matrix
samples <- matrix(NA, nrow = n_iter, ncol = 2,
dimnames = list(NULL, c("theta1", "theta2")))
current <- c(theta1 = 1, theta2 = 1)  # Initial values
# 3.nGibbs Sampling Main Loop
for (i in 1:n_iter) {
# (1)  Update theta1:Gamma(12, 3 + 1/x)
current["theta1"] <- rgamma(1, shape = 12, rate = 3 + 1/x)
# (2) Update theta2: Gamma(x + 0.5, 1)
current["theta2"] <- rgamma(1, shape = x + 0.5, rate = 1)
# Store current sample
samples[i, ] <- current
# Show progress every 2000 iterations
if (i %% 2000 == 0) {
cat(sprintf("Completed %d iterations\n", i, i))
}
}
# 4. Post-processing: Remove burn-in
post_samples <- samples[(burn_in + 1):n_iter, ]
# 5. Compute Statistics
#  Posterior means
post_means <- colMeans(post_samples)
#  95% Credible Intervals
post_ci <- apply(post_samples, 2, quantile, probs = c(0.025, 0.975))
# 6.  Display Results
results <- data.frame(
Parameter = c("θ₁", "θ₂"),
Mean = post_means,
Lower_CI = post_ci[1, ],
Upper_CI = post_ci[2, ],
row.names = NULL
)
knitr::kable(results,
caption = " Posterior Estimation Results",
digits = 3)
View(results)
#  Initial Setup
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
set.seed(1001)  #  Set random seed for reproducibility
# 1. Initialization
x <- 3          #  Observed data
n_iter <- 10000 #  Total iterations
burn_in <- 10 #  Burn-in period
# 2. Initialize storage matrix
samples <- matrix(NA, nrow = n_iter, ncol = 2,
dimnames = list(NULL, c("theta1", "theta2")))
current <- c(theta1 = 1, theta2 = 1)  # Initial values
# 3.nGibbs Sampling Main Loop
for (i in 1:n_iter) {
# (1)  Update theta1:Gamma(12, 3 + 1/x)
current["theta1"] <- rgamma(1, shape = 12, rate = 3 + 1/x)
# (2) Update theta2: Gamma(x + 0.5, 1)
current["theta2"] <- rgamma(1, shape = x + 0.5, rate = 1)
# Store current sample
samples[i, ] <- current
# Show progress every 2000 iterations
if (i %% 2000 == 0) {
cat(sprintf("Completed %d iterations\n", i, i))
}
}
# 4. Post-processing: Remove burn-in
post_samples <- samples[(burn_in + 1):n_iter, ]
# 5. Compute Statistics
#  Posterior means
post_means <- colMeans(post_samples)
#  95% Credible Intervals
post_ci <- apply(post_samples, 2, quantile, probs = c(0.025, 0.975))
# 6.  Display Results
results <- data.frame(
Parameter = c("θ₁", "θ₂"),
Mean = post_means,
Lower_CI = post_ci[1, ],
Upper_CI = post_ci[2, ],
row.names = NULL
)
knitr::kable(results,
caption = " Posterior Estimation Results",
digits = 3)
View(results)
View(results)
library(ggplot2)
library(dplyr)
library(bayesforecast)
set.seed(1001)
data <- 3
N <- 10000
thetas <- matrix(1, nrow = N, ncol = 2)
for (i in 2:N) {
thetas[i, 1] <- rbeta(1, 2 + data, 103 - data)
thetas[i, 2] <- rgamma(1, data + 0.5, 1)
}
thetas_trunc <- thetas[-(1:10), ]
gibbed <- data.frame(theta1 = thetas_trunc[, 1], theta2 = thetas_trunc[, 2])
ggacf(thetas_trunc)
p <- ggplot(gibbed, aes(x = theta1, y = theta2)) +
geom_bin2d(bins = 50) +
scale_fill_continuous(type = "viridis") +
theme_bw()
print(p)
summary_stats <- gibbed %>% summarise(mean_theta1 = mean(theta1), mean_theta2 = mean(theta2))
ci_theta1 <- quantile(gibbed$theta1, c(0.025, 0.975))
ci_theta2 <- quantile(gibbed$theta2, c(0.025, 0.975))
cat("Summary Stats:\n")
print(summary_stats)
cat("CI for theta1:", ci_theta1, "\n")
cat("CI for theta2:", ci_theta2, "\n")
library(ggplot2)
library(dplyr)
library(bayesforecast)
set.seed(1001)
data <- 3
N <- 10000
thetas <- matrix(1, nrow = N, ncol = 2)
for (i in 2:N) {
thetas[i, 1] <- rbeta(1, 2 + data, 103 - data)
thetas[i, 2] <- rgamma(1, data + 0.5, 1)
}
thetas_trunc <- thetas[-(1:10), ]
gibbed <- data.frame(theta1 = thetas_trunc[, 1], theta2 = thetas_trunc[, 2])
ggacf(thetas_trunc)
p <- ggplot(gibbed, aes(x = theta1, y = theta2)) +
geom_bin2d(bins = 50) +
scale_fill_continuous(type = "viridis") +
theme_bw()
print(p)
summary_stats <- gibbed %>% summarise(mean_theta1 = mean(theta1), mean_theta2 = mean(theta2))
ci_theta1 <- quantile(gibbed$theta1, c(0.025, 0.975))
ci_theta2 <- quantile(gibbed$theta2, c(0.025, 0.975))
cat("Summary Stats:\n")
print(summary_stats)
cat("CI for theta1:", ci_theta1, "\n")
cat("CI for theta2:", ci_theta2, "\n")
# STATS 3023/4023/7023 - Computational Bayesian Statistics
# Test 1 Solution
# Set random seed for reproducibility
set.seed(1001)
# Define observed data
x <- 3
# Gibbs Sampling Parameters
N <- 10000 # Number of samples
burn_in <- 10 # Burn-in period
# Initialize storage matrix for samples
# Column 1: theta1, Column 2: theta2
thetas <- matrix(NA, nrow = N, ncol = 2)
# Set initial values
thetas[1, ] <- c(1, 1) # Reasonable starting values
# Gibbs Sampling Implementation
for (i in 2:N) {
# Sample theta1 from its full conditional posterior (Beta distribution)
thetas[i, 1] <- rbeta(1, shape1 = 2 + x, shape2 = 103 - x)
# Sample theta2 from its full conditional posterior (Gamma distribution)
thetas[i, 2] <- rgamma(1, shape = x + 0.5, rate = 1)
}
# Remove burn-in samples
post_samples <- thetas[(burn_in + 1):N, ]
# Convert to data frame for easier handling
post_df <- data.frame(theta1 = post_samples[, 1], theta2 = post_samples[, 2])
# Calculate posterior means and 95% credible intervals
results <- list(
theta1_mean = mean(post_df$theta1), theta1_ci = quantile(post_df$theta1, c(0.025, 0.975)), theta2_mean = mean(post_df$theta2), theta2_ci = quantile(post_df$theta2, c(0.025, 0.975))
)
# Output results
cat("Posterior Mean Estimates:\n")
cat(sprintf("theta1: %.4f\n", results$theta1_mean))
cat(sprintf("theta2: %.4f\n\n", results$theta2_mean))
cat("95% Credible Intervals:\n")
cat("theta1: (", sprintf("%.4f", results$theta1_ci[1]), ", ", sprintf("%.4f", results$theta1_ci[2]), ")\n", sep = "")
cat("theta2: (", sprintf("%.4f", results$theta2_ci[1]), ", ", sprintf("%.4f", results$theta2_ci[2]), ")\n", sep = "")
# Optional: Visualizations
if (require(ggplot2)) {
# Plot autocorrelation to check mixing
acf_theta1 <- acf(post_df$theta1, plot = FALSE)
acf_theta2 <- acf(post_df$theta2, plot = FALSE)
# Plot joint distribution
joint_plot <- ggplot(post_df, aes(x = theta1, y = theta2)) +
geom_bin2d(bins = 50) +
scale_fill_viridis_c() +
theme_bw() +
labs(title = "Joint Posterior Distribution", x = expression(theta[1]), y = expression(theta[2]))
# Print plot (would be shown in RMarkdown/Quarto output)
print(joint_plot)
} else {
message("Install ggplot2 package for visualizations")
}
)
View(results)
# Optional: Visualizations
if (require(ggplot2)) {
# Plot autocorrelation to check mixing
acf_theta1 <- acf(post_df$theta1, plot = FALSE)
acf_theta2 <- acf(post_df$theta2, plot = FALSE)
# Plot joint distribution
joint_plot <- ggplot(post_df, aes(x = theta1, y = theta2)) +
geom_bin2d(bins = 50) +
scale_fill_viridis_c() +
theme_bw() +
labs(title = "Joint Posterior Distribution", x = expression(theta[1]), y = expression(theta[2]))
# Print plot (would be shown in RMarkdown/Quarto output)
print(joint_plot)
} else {
message("Install ggplot2 package for visualizations")
}
# Plot autocorrelation to check mixing
acf_theta1 <- acf(post_df$theta1, plot = FALSE)
acf_theta2 <- acf(post_df$theta2, plot = FALSE)
# Plot joint distribution
joint_plot <- ggplot(post_df, aes(x = theta1, y = theta2)) +
geom_bin2d(bins = 50) +
scale_fill_viridis_c() +
theme_bw() +
labs(title = "Joint Posterior Distribution", x = expression(theta[1]), y = expression(theta[2]))
# Print plot (would be shown in RMarkdown/Quarto output)
print(joint_plot)
View(post_df)
View(results)
exams2html("elasticity1.Rmd")
pacman::p_load(exams)
exams2html("elasticity1.Rmd")
exams2html("elasticity1.Rmd")
exams2html("elasticity2.Rmd")
exams2html("elasticity2.Rmd")
exams2html("elasticity2.Rmd")
setwd("~/Documents/quizbank")
exams2html("elasticity3.Rmd")
exams2html("elasticity3.Rmd")
exams2html("elasticity4.Rmd")
exams2html("elasticity4.Rmd")
sol <- 0
while(sol > -0.11) {
## p = a - b * x
p <- sample(5:15, 1)
fctr <- sample(c(2, 4, 5, 10), 1)
x <- sample(5:15, 1) * fctr
b <- sample(1:5, 1) / fctr
a <- p + b * x
## elasticity
sol <- -1/b * p/x
}
## single-choice incl. typical errors
err <- c(1/sol, sol/p, p/sol)
err <- err[(err > -5) & (err < -0.2) & abs(err - sol) > 0.01]
rng <- c(min(1.5 * sol, -1), -0.01)
sc <- num_to_schoice(sol, wrong = err, range = rng,
delta = 0.017, method = "delta", digits = 3)
sc
err
## single-choice incl. typical errors
err <- c(1/sol, sol/p, p/sol)
err <- err[(err > -5) & (err < -0.2) & abs(err - sol) > 0.01]
err
rng <- c(min(1.5 * sol, -1), -0.01)
sc <- num_to_schoice(sol, wrong = err, range = rng,
delta = 0.017, method = "delta", digits = 3)
sc
sc <- num_to_schoice(sol, wrong = err, range = rng,
delta = 0, method = "delta", digits = 3)
sc <- num_to_schoice(sol, wrong = err, range = rng,
delta = 0.1, method = "delta", digits = 3)
sc
sc <- num_to_schoice(sol, wrong = err, range = rng,
delta = 0.017, method = "delta", digits = 3)
sc
?num_to_schoice()
